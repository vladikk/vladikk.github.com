<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Vladikk</title>
    <link>https://vladikk.com/categories/Architecture/</link>
    <description>Recent content in Architecture on Vladikk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>vladik@khononov.com (Vladik Khononov)</managingEditor>
    <webMaster>vladik@khononov.com (Vladik Khononov)</webMaster>
    <lastBuildDate>Thu, 09 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vladikk.com/categories/Architecture/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Untangling Microservices, or Balancing Complexity in Distributed Systems</title>
      <link>https://vladikk.com/2020/04/09/untangling-microservices/</link>
      <pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate>
      <author>vladik@khononov.com (Vladik Khononov)</author>
      <guid>https://vladikk.com/2020/04/09/untangling-microservices/</guid>
      <description>The microservices-honeymoon period is over. Uber are refactoring their thousands of microservices into a more manageable solution [1], Kelsey Hightower says that monoliths are the future [2], and even Sam Newman maintains that microservices should never be the default choice, but rather a last resort [3].
What is going on here? Why so many projects became unmaintainable, despite the microservices’ promise of simplicity and flexibility? Or maybe monoliths better, after all?</description>
    </item>
    
    <item>
      <title>Anti-Pattern: Optimistic Consistency</title>
      <link>https://vladikk.com/2019/04/18/optimistic-consistency/</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      <author>vladik@khononov.com (Vladik Khononov)</author>
      <guid>https://vladikk.com/2019/04/18/optimistic-consistency/</guid>
      <description>Ladies and Gentlemen, lo and behold a new consistency model - “Optimistic Consistency”. Implementation of this pattern is quite simple: commit as many transactions as you want, against as many storage mechanisms as you need. That’s all. Let’s see an example.
Example Say as the result of some user’s operation the system has to:
 Modify data in MongoDB Publish some events to Kafka Update search model in Elasticsearch; and Execute an operation on some remote system  You implement this logic by executing those operations one after another.</description>
    </item>
    
    <item>
      <title>Zen of Software Engineering</title>
      <link>https://vladikk.com/2019/01/29/zen-software-engineering/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      <author>vladik@khononov.com (Vladik Khononov)</author>
      <guid>https://vladikk.com/2019/01/29/zen-software-engineering/</guid>
      <description>There is a pet peeve of mine, that I’m encountering way too often: the condition I call Silverbulletitis. This virus spreads among developers on many levels — juniors, seniors, and even architects. In this post I’d like talk about why this condition is dangerous, and how it can be treated.
Symptoms All too often you can hear statements that some tool or technique is bad, but another one is the greatest thing since sliced bread.</description>
    </item>
    
    <item>
      <title>Tackling Complexity in CQRS</title>
      <link>https://vladikk.com/2017/03/20/tackling-complexity-in-cqrs/</link>
      <pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate>
      <author>vladik@khononov.com (Vladik Khononov)</author>
      <guid>https://vladikk.com/2017/03/20/tackling-complexity-in-cqrs/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://vladikk.com/images/cqrs/title-img.jpg&#34; alt=&#34;Tackling Complexity in CQRS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The CQRS pattern can do wonders: it can maximize scalability, performance, security, and even &lt;a href=&#34;http://codebetter.com/gregyoung/2010/02/20/cqrs-and-cap-theorem/&#34;&gt;“beat” the CAP theorem&lt;/a&gt;. Nonetheless, CQRS has acquired a controversial name because of the complexity it introduces. For instance, &lt;a href=&#34;https://martinfowler.com/bliki/CQRS.html&#34;&gt;in his article on CQRS&lt;/a&gt;, Martin Fowler argues that the pattern should be applied sparingly and even cautiously:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“… for most systems CQRS adds risky complexity”&lt;/li&gt;
&lt;li&gt;“… you should be very cautious about using CQRS”&lt;/li&gt;
&lt;li&gt;“So while CQRS is a pattern that&amp;rsquo;s good to have in the toolbox, beware that it is difficult to use well and you can easily chop off important bits if you mishandle it.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From my point of view, the CQRS-induced complexity is largely accidental, and thus can be avoided. To illustrate my point, I want to discuss the goal of CQRS, and then analyze 3 common sources of accidental complexity in CQRS-based systems.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Finding Proper Scopes for Unit Tests</title>
      <link>https://vladikk.com/2016/06/29/test-scopes/</link>
      <pubDate>Wed, 29 Jun 2016 00:00:00 +0000</pubDate>
      <author>vladik@khononov.com (Vladik Khononov)</author>
      <guid>https://vladikk.com/2016/06/29/test-scopes/</guid>
      <description>&lt;p&gt;In my previous &lt;strike&gt;rant&lt;/strike&gt; &lt;a href=&#34;http://vladikk.com/2016/01/22/tdd-what-went-wrong/&#34;&gt;post on TDD&lt;/a&gt; I’ve argued that the majority of the problems many experience doing TDD are caused by testing in too narrow scopes - using classes as units of testability, instead of functional use cases. However, widening the scope of the test too much is just another extreme. So how one finds the sweet spot? In this post I’d like to share the heuristic that I use.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tackling Complexity in the Heart of DDD</title>
      <link>https://vladikk.com/2016/04/05/tackling-complexity-ddd/</link>
      <pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate>
      <author>vladik@khononov.com (Vladik Khononov)</author>
      <guid>https://vladikk.com/2016/04/05/tackling-complexity-ddd/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://vladikk.com/images/ddd/title-img.jpg&#34; alt=&#34;Tackling Complexity in the Heart of Domain-Driven Design&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s do a little experiment: try to explain the gist of Domain-Driven Design to someone who has no clue about it. This, especially doing it succinctly, is not easy. Heck, I struggle with it myself. Bounded contexts, entities, domain events, value objects, domains, aggregates, repositories… where do you even start?&lt;/p&gt;

&lt;p&gt;To find the order in the apparent chaos, I want to analyze the DDD methodology from a rather unusual perspective — by applying Domain-Driven Design to Domain-Driven Design itself. After all, this methodology is intended to deal with complex domains, isn’t it?&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>