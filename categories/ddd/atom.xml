<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DDD | Vladikk]]></title>
  <link href="http://www.vladikk.com/categories/ddd/atom.xml" rel="self"/>
  <link href="http://www.vladikk.com/"/>
  <updated>2016-04-05T19:31:17+03:00</updated>
  <id>http://www.vladikk.com/</id>
  <author>
    <name><![CDATA[Vladik Khononov]]></name>
    <email><![CDATA[vladik@khononov.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tackling Complexity in the Heart of Domain-Driven Design]]></title>
    <link href="http://www.vladikk.com/2016/04/05/tackling-complexity-ddd/"/>
    <updated>2016-04-05T19:14:00+03:00</updated>
    <id>http://www.vladikk.com/2016/04/05/tackling-complexity-ddd</id>
    <content type="html"><![CDATA[<p>Let’s do a little experiment: try to explain the gist of Domain-Driven Design to someone who has no clue about it. This is not an easy thing to do, especially to do it succinctly. Heck, I struggle with it too. Bounded contexts, entities, repositories, domain events, value objects, domains, aggregates, repositories, etc… where do you even start?</p>

<p>To find the hidden order in the apparent chaos, I want to analyze the DDD methodology from a rather unusual perspective — to apply Domain-Driven Design to Domain-Driven Design itself. It should deal with complex domains, right?</p>

<p>Let’s start by identifying the core domain: what is DDD’s main competitive advantage, and what are its means of achieving it?</p>

<h2>The Core Domain: Ubiquitous Language</h2>

<p>In «Domain-Driven Design: Tackling Complexity in the Heart of Software» (the Blue Book), Eric Evans argues that poor collaboration between domain experts and software development teams causes many development endeavors to fail. DDD aims to increase the success rates by bridging this collaboration and communication gap.</p>

<!-- more -->


<p>To allow fluent sharing of knowledge, DDD calls for cultivating a shared, business-oriented language - Ubiquitous Language. This language should resemble the business domain: its terms, entities, and processes.</p>

<p>The Ubiquitous Language should be extensively used throughout all stages of the project. All communication should be done in the Ubiquitous Language. All documentation should be formulated in it. Even the code should also "speak" the Ubiquitous Language.</p>

<p>Many methodologies strive to reduce risks and increase success rates of software projects, but since Ubiquitous Language is DDD’s means of achieving it, I consider it as the Core Domain of Domain-Driven Design.</p>

<p>Defining a Ubiquitous Language is not a trivial thing to do. Since software doesn't cope well with ambiguity, each Ubiquitous Language’s term should have exactly one meaning. Unfortunately, that's not how human languages work — words often bear different meanings in different contexts. To overcome this hurdle, and alleviate the process of cultivating a rigorous language, another DDD pattern is employed - Bounded Context.</p>

<h2>Supporting Sub-Domain: Bounded Contexts</h2>

<p>To prevent terms from having multiple meanings, DDD requires each language to have a strict applicability context — Bounded Context. This pattern defines a specific boundary, inside of which the Ubiquitous Language can be used freely, but outside of it, the language’s terms may have completely different meanings.</p>

<p>Although the Bounded Context pattern is an essential part of Domain-Driven Design, I consider it a Supporting Sub-Domain, since its purpose is to support the formation of a Ubiquitous Language - the Core Domain.</p>

<p>As I mentioned earlier, the code should also "speak" the Ubiquitous Language of the Bounded Context in which it is implemented. But how do you implement a business domain in code? There is no one-size-fits-all pattern for implementing a business domain. Multiple options are available, and that's our next stop. But be warned - holy cows are about to get injured...</p>

<h2>Generic Sub-Domain: Domain Implementation</h2>

<p>These patterns provide different ways of implementing the business domain's logic:</p>

<ol>
<li>Transaction Script</li>
<li>Active Record</li>
<li>Domain Model</li>
<li>Event-Sourced Domain Model</li>
</ol>


<p>Each of these patterns suits a different level of domain complexity. The pattern you choose, should be expressive enough to reify the Ubiquitous Language in code. It is crucial to point out this decision is not set in stone. As the business evolves and the Ubiquitous Language's complexity grows, the implementation pattern can be upgraded to a more elaborate one.</p>

<p>The aforementioned four patterns of business domain implementation are the ones with which I am currently familiar.</p>

<p>Indeed, there are may be others of which I am currently unaware.</p>

<p>New ones may be invented in the future.</p>

<p>Their implementation differs greatly in various programming paradigms.</p>

<p>Some best fit a certain programming paradigm but are complex to implement in others.</p>

<p>With all this volatility in mind, are they an essential part of Domain-Driven Design?</p>

<p>Since the Domain-Driven Design methodology cannot encompass all business domain implementation patterns, this know-how can, and should be, borrowed from other sources. For example, the Transaction Script, Active Record, and even Domain Model are described in Martin Fowler’s «Patterns of Enterprise Application Architecture» book. By definition, the ability to rely on «off-the-shelf» solutions makes them a Generic Sub-Domain. Yes, even the Domain Model pattern.</p>

<h2>Implications</h2>

<p>The decoupling of Domain-Driven Design from the tactical modeling patterns can have positive, far-reaching implications on DDD's accessibility and adoption rates. I want to elaborate on three of them: reducing DDD's complexity, widening its applicability, and the ability to gain a huge amount of traction by jumping on the Microservices bandwagon.</p>

<h3>1. Reduced Complexity</h3>

<p>This mind map by Eric Evans depicts the patterns that constitute the Domain-Driven Design methodology:
<img src="/images/ddd/ddd-patterns.png" alt="Domain-Driven Design Patterns" /></p>

<p>And this is how it will look if we drop the tactical modeling patterns:
<img src="/images/ddd/ddd-patterns2.png" alt="Domain-Driven Design Patterns" /></p>

<p>Shabang! Which one do you think will be easier to grasp and explain?</p>

<p>Decoupling of DDD from the Tactical Modeling patterns will prevent the multitude of misconceptions and difficulties many newcomers experience. For example, reading the first four chapters of the Blue Book and having a feeling they have got a strong understanding of DDD. And speaking of the Blue Book, many complain that it doesn't provide enough code samples. Well, guess what? Once DDD is decoupled from the Tactical Modeling patterns, it no longer requires any code samples at all. It is a pure system modeling methodology that can be applied in any technology stack and any software paradigm.</p>

<h3>2. Wider Applicability</h3>

<p>I strongly disagree with the notion that Domain-Driven Design should be applied solely to complex projects. This notion is driven by the strong coupling of DDD to the Domain Model pattern. Once we break this coupling, a whole new world of possibilities opens up:</p>

<h4>Communication</h4>

<p>No matter how simple the business domain is, if team members use different terminology for the same artifacts, sooner or later they will find themselves in the realm of accidental complexity. The Ubiquitous Language pattern prevents this scenario and yields a clear communication medium between all team members.</p>

<h4>Business Growth</h4>

<p>A domain's complexity increases more often than it decreases. This possibility of growth is highest for the so-called not complex projects. Once this happens, the implementation pattern decision should be rethought and adapted to the new complexity levels.</p>

<h3>3. Microservices</h3>

<p>Microservices are red hot nowadays. Widening the applicability of DDD to more project types will allow many microservices-based solutions to harness the invaluable DDD tools: The Bounded Context pattern provides a business-driven way of dividing a system into a set of independent services, and the Structure Map is a great way to map the services’ topology and interaction patterns between them.</p>

<h2>"Are You Nuts?"</h2>

<p>That's probably what you are thinking right now. However, I don't think that my proposition, to take the Tactical Patterns out of DDD, is as crazy as it initially sounds. Back at the DDD Europe 2016 conference, Eric Evans himself stated that the Domain Model implementation described in the Blue Book was intended to be <em>a</em> way of implementing a <em>Domain Model</em>, but many mistook it as <em>the</em> way of implementing <em>Domain-Driven Design</em>. See, the Tactical Modeling patterns were never intended to be the one and only true way of doing DDD, but many consider them as such. They produce extraneous noise and detract attention away from the most important and unique-to-DDD material.</p>

<p>Also, you cannot say that the Domain-Driven Design methodology is in its perfect state, and has no reason to change. Unfortunately, its low adoption rates speak volumes of its current state. DDD deserves way more attention than it gets. The Blue Book came out more than a decade ago, and since then the methodology has barely changed. I believe that it should change; not because it is bad, on the contrary, because it is great, but it has much, much more potential than it has realized.</p>

<h2>Final Thoughts</h2>

<p>In no way did I intend was to derogate the importance of Tactical Modeling. Quite the opposite - this subject deserves much more attention than it gets. However, it should be in its own context. There are many more patterns, besides the Domain Model, and more ways to implement them, than can fit in a single DDD book. These patterns can be implemented even on non-DDD projects, and a project can follow the DDD principles, even if its implementation has no aggregates in it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDDEU 2016 Impressions]]></title>
    <link href="http://www.vladikk.com/2016/02/12/dddeu-2016/"/>
    <updated>2016-02-12T22:27:00+02:00</updated>
    <id>http://www.vladikk.com/2016/02/12/dddeu-2016</id>
    <content type="html"><![CDATA[<p>Last month, I had the pleasure of attending the Domain Driven Design Europe conference in Brussels. As I’ve tweeted before, this was the best conference I’ve ever attended. In this post, I’d like to sum the things I’ve learned at the conference.</p>

<h2>It's Not (Only) About Sessions</h2>

<p>It was the first time I’ve attended a conference alone. Honestly, I was afraid that my introverted side would take over, and I’d master wallflower imitation techniques between sessions. Fortunately, it didn’t happen. I felt at home the moment I left the hotel for the conference. From that moment on, and up until the very last moments of the conference, I met a lot of like-minded people from all over the world - Belgium, Denmark, Germany, Austria, UK, Poland, Italy, France, USA, Finland, Switzerland, Netherlands, Romania, Bulgaria, and even from Israel.</p>

<p>For me, the social part, alone, was worth the trip. And don’t get me wrong, the sessions were great, but the ability to meet new friends, share experiences and ideas, and get fresh perspectives, was priceless.
And I’m yet to mention discussing Star Wars with Eric Evans, discovering that Vaughn Vernon knows Israel better than I do, catching up with Greg Young, and last but not least, drinking beer with Yves Reynhout — it is unbelievable how much I learned from Yves that evening.</p>

<p>Lesson learned: Go to conferences alone and meet new people.</p>

<!-- more -->


<h2>The State of DDD</h2>

<p>There was one thing that saddened me during the conference — the state of DDD. Let me explain.
I knew, that in Israel, DDD is not a common knowledge. I was pretty sure, that in Europe and the US, things are different, and DDD is a popular and accepted practice. The moment I started meeting new people, I got a feeling that this is far from truth. My surmise was confirmed when Vaughn took the stage to deliver his “oDDs &amp; enDs” talk.</p>

<p>Unfortunately, DDD is still in the underground, and it has a long road ahead to become a mainstream practice. To make it possible, the DDD community has to find a way to convince Eric to write the second edition of his seminal book.</p>

<h2>Sessions</h2>

<p>Although, for me, the sessions weren’t the critical part of the conference, they were great, nonetheless. The sessions that I liked the most:</p>

<ul>
<li>Eric Evan’s keynote - Nothing to explain here. Just go watch it the moment it will be available online.</li>
<li>“A Board Game Night with Geeks” by Felienne Hermans - Even though the <a href="https://twitter.com/DDD_Borat/status/693021883571240960">DDD police</a> was alert for this one, I really liked it. Felienne demonstrated the importance of choosing the right model and how crucial it is for solving problems.</li>
<li>“Jef &amp; Tom's Awesome Modellathon” — It was the first time I tried event storming hands-on, and boy, it was a great learning experience.</li>
<li>“Cognitive Cynefin” by Liz Keogh - I am a junkie for linguistics, and this session demonstrated DDD from a very unusual angle. The <a href="https://twitter.com/DDD_Borat/status/693021883571240960">DDD police</a> was wide awake here as well,  but Eric came to Liz’s rescue.</li>
<li>“Interviewing Domain Experts: Heuristics from the trenches” by Cyrille Martraire - This talk set the bar very high for the second day of the conference. Cyrille shared a lot of wisdom about talking to domain experts, in my opinion, a subject that deserves much more attention than it gets.</li>
<li>“oDDs &amp; enDs” by Vaughn Vernon - Just as with Eric’s keynote, nothing to explain here - a must-watch.</li>
<li>“A Decade of DDD, CQRS, Event Sourcing“ by Greg Young - A very entertaining and very informative session. Greg confirmed something that I was suspecting for a long time - Event Sourcing is the pattern that provides the real business value; CQRS is just a stepping stone to implement it.</li>
</ul>


<h2>DDDEU 2017</h2>

<p>To sum up, DDDEU 2016 was a great conference. A huge kudo goes to Mathias Verraes, Shawn McCool, Jeroen Gerits, DDDBE, and everyone else involved for making this happen. Can’t wait for DDDEU 2017 in Netherlands.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD: What Went Wrong…Or Did It?]]></title>
    <link href="http://www.vladikk.com/2016/01/22/tdd-what-went-wrong/"/>
    <updated>2016-01-22T20:57:00+02:00</updated>
    <id>http://www.vladikk.com/2016/01/22/tdd-what-went-wrong</id>
    <content type="html"><![CDATA[<p>Test Driven Development has been praised by our industry's aficionados for a long time. However, lately there have been many harsh words said towards TDD, as it’s being blamed for causing bad software design and not keeping many of its promises. This trend culminated in David Heinemeierhansson’s post <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">“TDD is dead. Long live testing”</a>.</p>

<p>How is it possible, that the same technique, which is so advantageous to so many developers, is so disastrous to others?
In this post I want to talk about 3 misconceptions that might explain this phenomenon.</p>

<p>Let's start with the subtlest and most destructive one.</p>

<h2>1. TDD is NOT “Test Driven <em>Design</em>”</h2>

<p>TDD stands for “Test Driven <em>Development</em>”. Unfortunately, many misinterpret this as “Test Driven <em>Design</em>”. This inaccuracy may sound innocent, but believe me, it isn't. Let me explain.</p>

<!-- more -->


<p>Test Driven Design implies that automatic tests should drive your software design decisions. Seriously? With all due respect, automatic tests are no end goal for developing software. The true goal is delivering projects on time, on budget, and most importantly, meeting all quality requirements. That's where all your design and development efforts should be aimed at.</p>

<p>If you design first and foremost for testability, you get what you pay for — testable code. More often than not, this design will be totally disconnected from the project's business domain and requirements. It will resemble an enormous object graph full of accidental complexities… but it will be testable. Testable by tests that are drowning in mocks, and will fail altogether after changing a single bit in the implementation. That's what they call "test induced damage", and it is vividly depicted in DHH’s <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">“TDD is Dead”</a> blog post:</p>

<blockquote><p>The current fanatical TDD experience leads to a primary focus on the unit tests, because those are the tests capable of driving the code design (the original justification for test-first) I don't think that's healthy. Test-first units leads to an overly complex web of intermediary objects and indirection in order to avoid doing anything that's "slow". Like hitting the database. Or file IO. Or going through the browser to test the whole system. It's given birth to some truly horrendous monstrosities of architecture. A dense jungle of service objects, command patterns, and worse.</p></blockquote>

<p>How it should be? Your business domain should drive your design decisions. Choose the implementation that best suits the problem you are trying to solve. There is no sense in a full-blown <a href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a> if all you need is a vanilla CRUD interface - implement the <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">Active Record pattern</a> instead! If all you need is an ETL script, go with the <a href="http://martinfowler.com/eaaCatalog/transactionScript.html">Transaction Script pattern</a>!</p>

<p>How on earth can it make sense to solve all problems with the same solution - hexagonal architecture and a domain model? "Because this design is ideal for unit tests!" I see. It's time to talk about the second misconception.</p>

<h2>2. TDD Isn't (only) About Unit Tests</h2>

<p>It is widely accepted that if you are doing TDD, you should write unit tests. This makes no sense. Unit tests are no magic bullet, and by the way, if you look up TDD on <a href="https://en.wikipedia.org/wiki/Test-driven_development">Wikipedia</a>, you won't find anything about unit tests:</p>

<blockquote><p>Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.</p></blockquote>

<p>The emphasis is on the automated tests, and they can be categorized into 3 types: unit tests, integration tests, and end-to-end tests. I don't believe that every project needs each and every one of them. Again, this decision should be driven by your problem domain:</p>

<ol>
<li>Are you dealing with complex business logic? You do need unit tests here</li>
<li>Are you only doing simple CRUD operations? Go ahead with integration tests, or event end-to-end tests</li>
<li>An ETL script? End-to-end tests will suffice</li>
</ol>


<p>Pick a testing strategy that best suits your domain. Write your tests first, and voila - you are doing TDD and not letting tests lead your design astray.</p>

<p>...And speaking of unit tests, what is a unit anyway?</p>

<h2>3. Unit != Class</h2>

<p>Another common misconception is that unit tests should be exercising individual classes, and all the class's dependencies should be mocked out. This approach is inaccurate. It is a recipe for strong coupling between tests and implementation. This coupling will undermine all your refactoring efforts, thus breaking one of the fundamental TDD promises.</p>

<p>The definition of a unit I like the most belongs to <a href="http://artofunittesting.com/definition-of-a-unit-test/">Roy Osherove</a>, the author of <a href="http://www.amazon.com/gp/product/1617290890">The Art of Unit Testing</a>:</p>

<blockquote><p>A unit test is an automated piece of code that invokes a unit of work in the system and then checks a single assumption about the behavior of that unit of work.</p>

<p>A unit of work is a single logical functional use case in the system that can be invoked by some public interface (in most cases). A unit of work can span a single method, a whole class or multiple classes working together to achieve one single logical purpose that can be verified.</p></blockquote>

<p>Testing functional uses cases uncouples the tests from the implementation. It will make refactoring possible, and will require significantly less mocking.</p>

<h2>The Missing "D" in TDD</h2>

<p>Ultimately, there is one more observation that I want to share, because it sums up all the aforementioned misconceptions.</p>

<p>It is recognized that a well-designed code is also a testable one. However, this relation is not commutative: well-designed code is testable, but not all testable code is well designed. The proof is trivial:</p>

<ul>
<li><p>How can you identify a testable code? Easy - by whether it has tests or not</p></li>
<li><p>How can you evaluate the design quality? Sorry, no shortcuts here - it is all about the context. A well-thought-out solution for one project is over-engineering for another. And over-engineering for one domain is negligence for a more complicated one.</p></li>
</ul>


<p>Therefore, even if the implementation is testable, it can still miss its problem and business domain by a mile. Consequently, the missing "D" in TDD is the business/problem "Domain". That's why I believe that <a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a>(DDD) is a prerequisite to Test Driven Development. The DDD methodology doesn't apply to complex domain models only - on the contrary, it defines a set of guidelines for choosing the best tool for the job according to the problem domain. But that's a topic for a whole other post.</p>

<h2>P.S. TDD 2.0</h2>

<p>TDD was "rediscovered" by Kent Beck over a decade ago. Perhaps it's about time for TDD to be rediscovered again. In addition to Unit Tests, the new specification should relate to other automated test types that weren't available back then. And of course, instead of working against, it should closely cooperate with the business domain.</p>
]]></content>
  </entry>
  
</feed>
